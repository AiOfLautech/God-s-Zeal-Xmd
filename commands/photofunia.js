const axios = require('axios');

const channelInfo = {
    forwardingScore: 1,
    isForwarded: true,
    forwardedNewsletterMessageInfo: {
        newsletterJid: '120363269950668068@newsletter',
        newsletterName: '‚ù¶ ‚ïê‚ïê‚ïê‚ïê ‚Ä¢‚ä∞‚ùÇ AI TOOLS HUB  ‚ùÇ‚ä±‚Ä¢ ‚ïê‚ïê‚ïê‚ïê ‚ù¶',
        serverMessageId: -1
    }
};

// PhotoFunia effects database - organized by category
const photofuniaEffects = {
    'texteffects': {
        'love': 'Love Effect',
        'cup': 'Cup Effect',
        'carbon': 'Carbon Text',
        'write': 'Writing Effect',
        'luxury': 'Luxury Text',
        'blood': 'Blood Text',
        'neon': 'Neon Writing',
        'smoke': 'Smoke Effect',
        'ice': 'Ice Text',
        'fire': 'Fire Text',
        'thunder': 'Thunder Effect',
        'matrix': 'Matrix Effect',
        'hacker': 'Hacker Effect',
        'glitch': 'Glitch Effect',
        'sand': 'Sand Text',
        'leaves': 'Leaves Effect',
        'blackpink': 'Blackpink Effect',
        'purple': 'Purple Text',
        'devil': 'Devil Effect',
        'watercolour': 'Watercolour Text',
        'christmas': 'Christmas Writing',
        'metallic': 'Metallic Text',
        'snow': 'Snow Text',
        'impressive': 'Impressive Text',
        'light': 'Light Text',
        'arena': 'Arena Effect',
        '1917': '1917 Effect'
    },
    'frames': {
        'countryhome': 'Country House',
        'melbourne': 'Melbourne Gallery',
        'brussels': 'Brussels Museum',
        'rijksmuseum': 'Rijksmuseum',
        'gallery': 'At the Gallery',
        'theframe': 'The Frame',
        'oldtvset': 'Old TV Set',
        'billboard': 'Billboard Effect',
        'timessquare': 'Times Square After Rain',
        'broadway': 'Broadway at Night',
        'newyork': 'New York at Night',
        'concrete': 'Concrete Jungle',
        'vintage': 'Vintage Scooter'
    },
    'seasonal': {
        'valentine': "Valentine's Day",
        'easter': 'Easter Greetings',
        'christmas': 'Christmas Effect',
        'halloween': 'Halloween Pumpkins',
        'beach': 'Beach Sign',
        'snow': 'Snow Sign'
    },
    'vehicles': {
        'harley': 'Harley Davidson',
        'surfing': 'Surfing Board'
    },
    'cards': {
        'flowers': 'Card with Flowers',
        'balloon': 'Hot Air Balloon',
        'newspaper': 'Morning Newspaper',
        'morningpaper': 'Morning Paper',
        'calendar': 'Calendar'
    },
    'professions': {
        'painter': 'Painter',
        'street': 'Street Artist'
    },
    'misc': {
        'heart': 'Heart Effect',
        'smoke': 'Smoke Flare',
        'glitter': 'Glitter Effect',
        'spark': 'Sparkle Effect'
    }
};

// Get all available effects
function getAllEffects() {
    const allEffects = {};
    Object.values(photofuniaEffects).forEach(category => {
        Object.assign(allEffects, category);
    });
    return allEffects;
}

// Get effects by category
function getEffectsByCategory(category) {
    return photofuniaEffects[category.toLowerCase()] || null;
}

// Format effect name from command
function normalizeEffectName(name) {
    return name.toLowerCase().replace(/\s+/g, '');
}

const messageTemplates = {
    error: (message) => ({
        text: message,
        contextInfo: channelInfo
    }),
    success: (text, imageUrl, effectName) => ({
        image: { url: imageUrl },
        caption: `*${text.toUpperCase()}*\n\n_Effect: ${effectName}_\n\nGENERATED BY GODSZEAL XMD`,
        contextInfo: channelInfo
    })
};

async function photofuniaCommand(sock, chatId, message, q, type) {
    try {
        const normalizedType = normalizeEffectName(type);
        const allEffects = getAllEffects();
        
        if (!allEffects[normalizedType]) {
            const availableEffects = Object.keys(allEffects).join(', ');
            return await sock.sendMessage(chatId, messageTemplates.error(
                `‚ùå Invalid effect: *${type}*\n\n` +
                `üìã Available effects:\n\n${availableEffects.split(',').slice(0, 20).join('\n')}\n\n` +
                `... and more!\n\n` +
                `Usage: .${normalizedType} <text>`
            ));
        }

        if (!q) {
            const effectName = allEffects[normalizedType];
            return await sock.sendMessage(chatId, messageTemplates.error(
                `‚ùå Please provide text to generate\n\n` +
                `Effect: ${effectName}\n\n` +
                `Example: .${type} Godszeal`
            ));
        }

        const text = q.trim();
        const baseUrl = "https://api.giftedtech.co.ke/photofunia";
        
        const endpoint = `${baseUrl}/${normalizedType}?text=${encodeURIComponent(text)}`;

        const response = await axios.get(endpoint, { timeout: 10000 });
        if (response.data && response.data.url) {
            await sock.sendMessage(chatId, messageTemplates.success(text, response.data.url, allEffects[normalizedType]));
        } else {
            throw new Error('No image URL received from the API');
        }
    } catch (error) {
        console.error('Error in photofunia command:', error);
        await sock.sendMessage(chatId, messageTemplates.error(
            `‚ùå Error: ${error.message || 'Failed to generate effect'}`
        ));
    }
}

// List all effects in a category
async function listEffectsByCategory(sock, chatId, category) {
    try {
        const effects = getEffectsByCategory(category);
        if (!effects) {
            const categories = Object.keys(photofuniaEffects).join(', ');
            return await sock.sendMessage(chatId, messageTemplates.error(
                `‚ùå Invalid category: *${category}*\n\n` +
                `üìã Available categories:\n${categories}`
            ));
        }

        const effectsList = Object.entries(effects)
            .map(([cmd, name]) => `‚Ä¢ .${cmd} - ${name}`)
            .join('\n');

        await sock.sendMessage(chatId, {
            text: `*üì∏ PhotoFunia ${category.toUpperCase()} Effects*\n\n${effectsList}`,
            contextInfo: channelInfo
        });
    } catch (error) {
        console.error('Error listing effects:', error);
        await sock.sendMessage(chatId, messageTemplates.error(`Error: ${error.message}`));
    }
}

// List all categories
async function listAllCategories(sock, chatId) {
    try {
        const categories = Object.keys(photofuniaEffects)
            .map(cat => `‚Ä¢ .pflist ${cat}`)
            .join('\n');

        const totalEffects = Object.values(photofuniaEffects).reduce((sum, cat) => sum + Object.keys(cat).length, 0);

        await sock.sendMessage(chatId, {
            text: `*üé® PhotoFunia Commands*\n\n` +
                  `Total Effects: ${totalEffects}\n\n` +
                  `*Categories:*\n${categories}\n\n` +
                  `Usage: .pflist <category>\n` +
                  `Or use any effect directly: .<effect> <text>`,
            contextInfo: channelInfo
        });
    } catch (error) {
        console.error('Error listing categories:', error);
        await sock.sendMessage(chatId, messageTemplates.error(`Error: ${error.message}`));
    }
}

// Search for effects by keyword
async function searchEffects(sock, chatId, keyword) {
    try {
        const allEffects = getAllEffects();
        const searchTerm = keyword.toLowerCase();
        const results = Object.entries(allEffects)
            .filter(([cmd, name]) => cmd.includes(searchTerm) || name.toLowerCase().includes(searchTerm))
            .map(([cmd, name]) => `‚Ä¢ .${cmd} - ${name}`)
            .join('\n');

        if (!results) {
            return await sock.sendMessage(chatId, messageTemplates.error(
                `‚ùå No effects found matching: *${keyword}*`
            ));
        }

        await sock.sendMessage(chatId, {
            text: `*üîç PhotoFunia Search Results*\n\nKeyword: ${keyword}\n\n${results}`,
            contextInfo: channelInfo
        });
    } catch (error) {
        console.error('Error searching effects:', error);
        await sock.sendMessage(chatId, messageTemplates.error(`Error: ${error.message}`));
    }
}

module.exports = {
    photofuniaCommand,
    listEffectsByCategory,
    listAllCategories,
    searchEffects,
    getAllEffects,
    getEffectsByCategory
};
